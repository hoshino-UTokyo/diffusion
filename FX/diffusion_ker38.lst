Fujitsu C/C++ Version 4.5.0   Fri Jul  2 22:56:59 2021
Compilation information
  Current directory : /work/01/gz00/z30108/bouken_no_sho/Odyssey/Diffusion/FX
  Source file       : diffusion_ker38.c
(line-no.)(optimize)
        1             #include <stdio.h>
        2             #include <stdlib.h>
        3             #include <math.h>
        4             #include <omp.h>
        5             #ifdef SVE
        6             #include <arm_sve.h>
        7             #endif /* SVE */
        8             #include "diffusion_ker38.h"
        9             
       10             #ifndef REAL
       11             #define REAL double
       12             #endif
       13             
       14             #ifndef M_PI
       15             #define M_PI (3.1415926535897932384626)
       16             #endif
       17             
       18             #ifndef MIN
       19             #define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
       20             #endif
       21             #ifndef MAX
       22             #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
       23             #endif
       24             
       25             #define YBF 8
       26             #define HALO 1
       27             #define ZB (3+HALO-1)
       28             #define STEP 3
       29             #define TB (HALO+STEP-2)
       30             #define SIMDLENGTH 8
       31             
       32             void allocate_ker38(REAL **buff_ret, const int nx, const int ny, const int nz) {
       33             
       34               posix_memalign((void**)buff_ret, 64, sizeof(REAL)*nx*ny*nz);
       35             
       36             }
       37             
       38             void init_ker38(REAL *buff1, const int nx, const int ny, const int nz,
       39             		const REAL kx, const REAL ky, const REAL kz,
       40             		const REAL dx, const REAL dy, const REAL dz,
       41             		const REAL kappa, const REAL time) {
       42             
       43               REAL ax, ay, az;
       44               int jz, jy, jx;
       45               ax = exp(-kappa*time*(kx*kx));
       46               ay = exp(-kappa*time*(ky*ky));
       47               az = exp(-kappa*time*(kz*kz));
       48             #pragma omp parallel private(jx,jy,jz)
       49               {
       50             /*     int tid = omp_get_thread_num(); */
       51             /*     int nth = omp_get_num_threads(); */
       52             /*     int tz = tid/12; */
       53             /*     int ty = tid%12; */
       54             /*     int zchunk = nz/((nth-1)/12+1); */
       55             /*     int yblock = YBF; */
       56             /*     int ychunk = yblock * 12; */
       57                 int xx,yy;
       58                 int tid = omp_get_thread_num();
       59                 int nth = omp_get_num_threads();
       60                 int ty = tid;
       61                 int ychunk = YBF*nth;
       62                 int yystr = ty*YBF;
       63             /*     int yystr = ty*yblock; */
       64                 /* for (yy = yystr; yy < ny; yy+= ychunk) { */
       65                 /*   for (jz = tz*zchunk; jz < MIN((tz+1)*zchunk,nz); jz++) { */
       66                 /* 	for (jy = yy; jy < MIN(yy+yblock,ny); jy++) { */
       67                 /* 	  for (jx = 0; jx < nx; jx++) { */
       68                 //#pragma omp parallel for private(yy,jx,jy,jz)
       69                 for (yy = yystr; yy < ny; yy+= ychunk) {
       70                   for (jz = 0; jz < nz; jz++) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    PREFETCH(HARD) Expected by compiler :
                       <<<      (unknown)
                       <<< Loop-information  End >>>
       71             	for (jy = yy; jy < MIN(yy+YBF,ny); jy++) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: 8)
                       <<<    SOFTWARE PIPELINING(IPC: 1.37, ITR: 128, MVE: 6, POL: L)
                       <<<    PREFETCH(HARD) Expected by compiler :
                       <<<      (unknown)
                       <<<    SPILLS :
                       <<<      GENERAL   : SPILL 0  FILL 0
                       <<<      SIMD&FP   : SPILL 0  FILL 0
                       <<<      SCALABLE  : SPILL 0  FILL 54
                       <<<      PREDICATE : SPILL 0  FILL 0
                       <<< Loop-information  End >>>
       72          v  	  for (jx = 0; jx < nx; jx++) {
       73          v  	    int j = jz*nx*ny + jy*nx + jx;
       74          v  	    REAL x = dx*((REAL)(jx + 0.5));
       75          v  	    REAL y = dy*((REAL)(jy + 0.5));
       76          v  	    REAL z = dz*((REAL)(jz + 0.5));
       77          v  	    REAL f0 = (REAL)0.125
       78             	      *(1.0 - ax*cos(kx*x))
       79             	      *(1.0 - ay*cos(ky*y))
       80             	      *(1.0 - az*cos(kz*z));
       81          v  	    buff1[j] = f0;
       82          v  	  }
       83             	}
       84                   }
       85                 }
       86               }
       87             }
       88             
       89             
       90             void diffusion_ker38(REAL *restrict f1, REAL *restrict f2, int nx, int ny, int nz,
       91             		     REAL ce, REAL cw, REAL cn, REAL cs, REAL ct,
       92             		     REAL cb, REAL cc, REAL dt,
       93             		     REAL **f1_ret, REAL **f2_ret, REAL *time_ret, int *count_ret) {
       94             
       95             #pragma omp parallel
       96               {
       97                 REAL time = 0.0;
       98                 int count = 0;
       99                 REAL *restrict f1_t = f1;
      100                 REAL *restrict f2_t = f2;
      101                 int c, w, e, n, s, b, t,b0, t0, n0, s0;//, nt0, st0, w0, e0;
      102                 int z, y, x, xx, yy, zz, h;
      103                 int izm,izc,izp,iy,ix,tmp,halo;
      104                 int step;
      105                 int xstr,xend,ystr,yend;
      106                 int id2,id1;
      107             
      108                 int tid = omp_get_thread_num();
      109                 int nth = omp_get_num_threads();
      110                 int ty = tid;
      111                 int ychunk = YBF*nth;
      112                 int yystr = ty*YBF;
      113             
      114                 REAL *temporal;
      115                 temporal = (REAL*)malloc(sizeof(double)*(STEP-1)*(2*HALO+1)*(YBF+2*TB)*nx);
      116                 int tbx = nx;
      117                 int tby = (YBF+2*TB);
      118                 int tbz = (2*HALO+1);
      119             
      120                 const svfloat64_t cc_vec = svdup_f64(cc);
      121                 const svfloat64_t cw_vec = svdup_f64(cw);
      122                 const svfloat64_t ce_vec = svdup_f64(ce);
      123                 const svfloat64_t cs_vec = svdup_f64(cs);
      124                 const svfloat64_t cn_vec = svdup_f64(cn);
      125                 const svfloat64_t cb_vec = svdup_f64(cb);
      126                 const svfloat64_t ct_vec = svdup_f64(ct);
      127                 const svbool_t pg = svptrue_b64();
      128             #pragma statement cache_sector_size 4 0 2 14
      129             #pragma statement cache_subsector_assign temporal
      130                 do {
      131                   for (yy = yystr; yy < ny; yy+=ychunk) {
      132             
      133             	if(yy == 0){
      134             #define YY 0
      135             #include "ker38.inc"
      136             #undef YY 
      137             	}else if(yy >= ny-YBF){
      138             #define YY 2
      139             #include "ker38.inc"
      140             #undef YY 
      141             	}else{
      142             #define YY 1
      143             #include "ker38.inc"
      144             #undef YY 
      145             	}
      146                   }
      147              
      148             #pragma omp barrier
      149                   REAL *tmp = f1_t;
      150                   f1_t = f2_t;
      151                   f2_t = tmp;
      152                   time += STEP*dt;
      153                   //time += 1;
      154                   count+=STEP;
      155                   
      156                 } while (time + 0.5*dt < 0.1);
      157             #pragma omp master
      158   s             {
      159   s               *f1_ret = f1_t; *f2_ret = f2_t;
      160   s               *time_ret = time;      
      161   s               *count_ret = count;        
      162   s             }
      163             #pragma statement end_cache_subsector
      164             #pragma statement end_cache_sector_size
      165                 free(temporal);
      166               }
      167               
      168             }
      169             
      170             #undef YBF
      171             #undef HALO 
      172             #undef ZB 
      173             #undef STEP 
      174             #undef TB 
      175             #undef SIMDLENGTH
Total prefetch num: 0
Statistics information
  Option information
    Command line options : -c -Kfast,openmp -O3 -DSVE -DBLAS -Khpctag -Nfjomplib -Nfjprof -Kswp_strong -Nlst=t -Koptmsg=guide
    Effective options    : -g0 -mt -Qy -std=gnu11 -x- -O3 -Knoalias_const -Kalign_loops
                           -Karray_declaration_opt -Kassume=noshortloop
                           -Kassume=nomemory_bandwidth -Kassume=notime_saving_compilation
                           -Kcmodel=small -Kconst -Keval -Keval_noconcurrent
                           -Knoextract_stride_store -Kfast_matmul -Knofconst -Knofenv_access
                           -Kfp_contract -Kfp_relaxed -Kfsimple -Kfz -Khpctag
                           -Kilfunc=procedure -Klargepage -Klib -Kloop_blocking
                           -Kloop_fission -Kloop_nofission_stripmining
                           -Kloop_fission_threshold=50 -Kloop_fusion -Kloop_interchange
                           -Kloop_part_simd -Kloop_perfect_nest -Kloop_noversioning
                           -Klooptype=f -Knomemalias -Kmfunc=1 -Knoocl -Komitfp -Kopenmp
                           -Kopenmp_noassume_norecurrence
                           -Kopenmp_nocollapse_except_innermost -Kopenmp_noordered_reduction
                           -Knoopenmp_simd -Knooptlib_string -Knooptmsg
                           -Knopc_relative_literal_loads -Knoparallel
                           -Kparallel_nofp_precision -Knopreex -Kprefetch_cache_level=all
                           -Kprefetch_noconditional -Kprefetch_noindirect -Kprefetch_noinfer
                           -Kprefetch_sequential=auto -Kprefetch_nostride -Kprefetch_strong
                           -Kprefetch_strong_L2 -Knopreload -Krdconv=1 -Krestp=restrict
                           -Ksch_post_ra -Ksch_pre_ra -Ksibling_calls -Ksimd=auto
                           -Ksimd_packed_promotion -Ksimd_reduction_product
                           -Ksimd_reg_size=512 -Ksimd_nouncounted_loop
                           -Ksimd_use_multiple_structures -Knostrict_aliasing -Knostriping
                           -KA64FX -KARMV8_3_A -KSVE -Kswp_strong -Kswp_freg_rate=100
                           -Kswp_ireg_rate=100 -Kswp_preg_rate=100 -Kswp_policy=auto
                           -Kunroll -Knounroll_and_jam -Knozfill
                           -Ncancel_overtime_compilation -Nnocoverage -Nnoexceptions
                           -Nnofjcex -Nfjprof -Nnohook_func -Nnohook_time -Nfjomplib -Nline
                           -Nlst=p -Nlst=t -Nquickdbg=noheapchk -Nquickdbg=nosubchk
                           -NRnotrap -Nnoreordered_variable_stack -Nrt_notune
                           -Nsetvalue=noheap -Nsetvalue=nostack -Nsetvalue=noscalar
                           -Nsetvalue=noarray -Nsetvalue=nostruct -Nsrc -Nsta
